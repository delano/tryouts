#!/usr/bin/env ruby

# Coverage tracking (must be first)
if ENV['COVERAGE'] || ENV['SIMPLECOV']
  require 'simplecov'
  # Reset any existing coverage data to prevent line count mismatches
  Coverage.result(stop: false, clear: true) if defined?(Coverage)
  SimpleCov.start do
    track_files 'lib/**/*.rb'
    add_filter '/try/'
    add_filter '/test/'
    add_filter '/test_'
    add_filter '/spec/'
    add_filter '/examples/'
    add_filter '/docs/'

    add_group 'Core', 'lib/tryouts.rb'
    add_group 'CLI', 'lib/tryouts/cli'
    add_group 'Formatters', 'lib/tryouts/cli/formatters'
    add_group 'Parsers', 'lib/tryouts/parsers'
    add_group 'Data Structures', ['lib/tryouts/testcase.rb', 'lib/tryouts/testbatch.rb']
    add_group 'Translators', 'lib/tryouts/translators'
    add_group 'Execution', ['lib/tryouts/test_executor.rb', 'lib/tryouts/test_runner.rb', 'lib/tryouts/file_processor.rb']

    coverage_dir 'coverage'

    # Coverage thresholds disabled to prevent CI failures
    # minimum_coverage 80
    # minimum_coverage_by_file 70
  end

  SimpleCov.command_name 'Tryouts CLI'
end

require_relative '../lib/tryouts'

# Add development library paths
lib_glob = File.join(Dir.pwd, '{lib,../lib,.}')
Tryouts.update_load_path(lib_glob) if Tryouts.respond_to?(:update_load_path)

# Capture original command for agent mode before ARGV gets modified
original_command = [$0] + ARGV

# Parse args and run CLI
begin
  files, options = Tryouts::CLI.parse_args(ARGV)

  # Add original command to options for agent formatter
  options[:original_command] = original_command

  # Track whether user explicitly provided paths
  explicit_paths_given = !files.empty?

  # Expand files if directories are given, preserving line specs
  expanded_files = []
  files.each do |file_or_dir|
    # Parse line spec from the argument
    path_part, line_spec = Tryouts::CLI::LineSpecParser.parse(file_or_dir)

    if File.directory?(path_part)
      # If it's a directory, find all *_try.rb and *.try.rb files within it
      dir_files = Dir.glob(['**/*_try.rb', '**/*.try.rb'], base: path_part)
      expanded_files.concat(dir_files.map { |f| File.join(path_part, f) })
    else
      # If it's a file, add it as-is (with line spec if present)
      expanded_files << file_or_dir
    end
  end
  files          = expanded_files

  # If user provided explicit paths but nothing matched, exit with error
  if explicit_paths_given && files.empty?
    warn 'Error: No test files found matching the given paths'
    exit 1
  end

  # Default file discovery if no files specified
  if files.empty?
    raw_files = Dir.glob(
      ['{app,apps,lib,try,tryouts}/**/*_try.rb', './*_try.rb', '{app,apps,lib,try,tryouts}/**/*.try.rb', './*.try.rb'],
      base: Dir.pwd,
    )

    # Normalize paths so that slight variations are ignored
    # e.g. ./test_try.rb and ././test_try.rb
    files     = raw_files.map { |f| File.expand_path(f, Dir.pwd) }.uniq.sort
  else
    # Normalize paths for explicitly specified files/directories
    files = files.map { |f| File.expand_path(f, Dir.pwd) }.uniq.sort
  end

  cli = Tryouts::CLI.new
  exit cli.run(files, **options)
rescue StandardError => ex
  warn "Error: #{ex.message}"
  warn ex.backtrace.join("\n") if options&.dig(:debug)
  exit 1
end
